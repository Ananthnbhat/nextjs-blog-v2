---
title: 'Show fallback UI while component load'
date: '2023-12-06'
lastmod: '2024-01-01'
tags: ['react', 'ux']
# layout: ListLayout
summary: 'If a component is known to take long time to load, use Suspense to show fallback UI for better UX'
---

<TOCInline toc={props.toc} exclude="Overview" />

## What is `<Suspense />` in React js?

It is an in-built component in react that can be used to show an alternate UI while the main UI loads. For example, if a component is in the proccess of fetching some data,
we can show a lightweight alternate React node (like a loading page/spinner) until the fetching completes.

```jsx
import React, {Suspense} from 'react';
import MenuBasedOnDate from './MenuBasedOnDate';
import Loading from './components/Loading';
...
<Suspense fallback={<Loading />}>
  <MenuBasedonDate />
</Suspense>
...
```

## When to use it?

When a component requires time to load and it satisfies one of the below conditions -

- it is fetching some data and returns a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) like response.
- it is [lazy loaded](#lazy-loading)
- it returns response using [use](https://react.dev/reference/react/use)

Using Suspense also promotes a better user experience as user is informed continuously about the what is happening on the screen.

### Wrapping Suspense around data fetching component

```jsx:App.jsx
import React, {Suspense} from 'react';
...

const DataFetchingComponent = () => {
  const date = fetchSomeData(); // This can be any async call, such as API call.

  return <div>{data.xyz}</div>;
};

...
const App = () => {
  return (
    <Suspense fallback={<Loading />}>
      <DataFetchingComponent />
    </Suspense>
  );
};
```

### Lazy loading

Lazy loading is a [code splitting](https://developer.mozilla.org/en-US/docs/Glossary/Code_splitting) technique that can increase the performance of an application if it grows too big.
It is used for dynamically loading a component only when its required (needs to be rendered/used).

```jsx:App.jsx
import { lazy } from 'react';

const LazyLoadedComponent = lazy(() => import('./LazyLoadedComponent.js'));
...
const App = () => {
  return (
    <Suspense fallback={<Loading />}>
      <LazyLoadedComponent />
    </Suspense>
  )
}
```

In the above example, the `<LazyLoadedComponent />` is only loaded when `<App />` is getting rendered. While the lazy component is getting loaded,
it will be in a suspended state and hence the fallback UI `<Loading />` will be shown to the user.

## Things to note

- Suspense component can be wrapped around multiple nested component. This also means that the fallback UI will be visible until every children loads.
- The closest parent Suspense component gets activated if a child suspends, meaning there can be multiple Suspense components but only the closest parent component matters
  for the loading children node.

## Show the stale state instead of fallback UI

Sometimes, we may want to show the previous state of a component while its loading, instead of showing the fallback UI. For example, assume there is a menu for a restaurat which changes based
on the date. If the date input is modified, then we can keep showing the previous menu until the new menu is fetched & loaded. This can be achieved using
a react hook called [useDeferredValue](https://react.dev/reference/react/useDeferredValue) as shown below -

```jsx:App.jsx
import React, {useState, useDeferredValue, Suspense} from 'react';
...
const App = () => {
  ...
  const [date, setDate] = useState('');
  const deferredDate = useDeferredValue(date);
  return (
    <>
      <label>
        Search flights:
        <input value={date} onChange={e => setDate(e.target.value)} />
      </label>
      <Suspense fallback={<h2>Loading...</h2>}>
        <MenuBasedOnDate latestDate={deferredDate} />
      </Suspense>
    </>
  );
}
```

When the date value is updated by the user, the deferredDate still has the older value of the date since we have chosen to ignore new date for a while
(as we have used useDeferredValue hook). So, once the page re-renders (due to setDate()), deferredDate still has the old date. Then react tries to re-render again to show the
new date. If this 2nd re-renderig is successful then the deferredDate will have the new date value that is passd to the `<MenuBasedOnDate />` component

## Caveats

## Conclusion

---

## Sources

- [React docs](https://react.dev/reference/react/Suspense)
